// Lightweight checks to keep the dataset consistent.
// Run with: mongosh tests/data_quality.mongosh.js

// Use the same DB name configured in .env
db = db.getSiblingDB("group_22");

const expectations = [
  // Ensure base collections were seeded.
  {
    label: "restaurants present",
    validator: () => (db.restaurants.countDocuments({}) === 0 ? 1 : 0),
    expected: 0,
  },
  {
    label: "orders present",
    validator: () => (db.orders.countDocuments({}) === 0 ? 1 : 0),
    expected: 0,
  },
  // Ensure derived collections were generated by the seed script.
  {
    label: "menu_items generated",
    validator: () => (db.menu_items.countDocuments({}) === 0 ? 1 : 0),
    expected: 0,
  },
  {
    label: "order_items generated",
    validator: () => (db.order_items.countDocuments({}) === 0 ? 1 : 0),
    expected: 0,
  },
  // Guard against corrupt documents missing order items.
  {
    label: "orders with items",
    collection: "orders",
    query: { items: { $size: 0 } },
    expected: 0,
  },
  // Referential integrity checks.
  {
    label: "orders reference restaurants",
    validator: () => db.orders.countDocuments({ restaurantId: { $nin: db.restaurants.distinct("_id") } }),
    expected: 0,
  },
  {
    label: "menu_items reference restaurants",
    validator: () => db.menu_items.countDocuments({ restaurantId: { $nin: db.restaurants.distinct("_id") } }),
    expected: 0,
  },
  {
    label: "order_items reference orders",
    validator: () => db.order_items.countDocuments({ orderId: { $nin: db.orders.distinct("_id") } }),
    expected: 0,
  },
];

// Optional: enable strict-mode to assert exact counts based on fixtures in `data/`
// Set `strictMode` to `true` to fail the checks if counts don't match expectations.
const strictMode = true;
const expectedCounts = {
  restaurants: 50,
  orders: 50,
  menu_items: 100,
  order_items: 100,
};

if (strictMode) {
  expectations.push(
    { label: "restaurants count", validator: () => db.restaurants.countDocuments({}), expected: expectedCounts.restaurants },
    { label: "orders count", validator: () => db.orders.countDocuments({}), expected: expectedCounts.orders },
    { label: "menu_items count", validator: () => db.menu_items.countDocuments({}), expected: expectedCounts.menu_items },
    { label: "order_items count", validator: () => db.order_items.countDocuments({}), expected: expectedCounts.order_items }
  );
}

let failures = 0;
expectations.forEach((check) => { 
  let actual;
  if (check.validator) {
    actual = check.validator();
  } else {
    actual = db.getCollection(check.collection).countDocuments(check.query);
  }

  const ok = actual === check.expected;
  print(`[${ok ? "OK" : "FAIL"}] ${check.label} -> expected ${check.expected}, got ${actual}`);
  if (!ok) failures += 1;
});

if (failures === 0) {
  print("All sanity checks passed.");
} else {
  throw new Error(`${failures} checks failed. Fix the dataset before committing.`);
}
